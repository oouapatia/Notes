[toc]

### 一、执行

**（1）使用绝对路径或相对路径执行**

在本shell的子shell中执行，不能获取sh文件中的变量

- 绝对路径

  `/xxx/xx/add.sh`

- 相对路径

  `./add.sh`

**（2）用bash或sh来执行**

在本shell的子shell中执行，不能获取sh文件中的变量

- `bash add.sh`
- `sh add.sh`

**（3）用source或`.`来执行**

==在本shell执行==

- `source test.sh`
- `. test.sh`

### 二、变量

#### （1）定义变量

- 定义变量时，变量名不加`$`符号
  - 变量名和等号之间不能有空格
  - 如：`name="type"`

#### （2）使用变量

- 在变量名前加`$`符号
  - 变量外的花括`{}`号可选，花括号是为了帮助解释器识别变量的边界，推荐均加上

#### （3）只读变量

- 使用`readonly`命令将变量定义为只读变量，只读变量的值不能被改变
  - 例：`readonly name`

#### （4）删除变量

- 使用`unset`命令合一删除变量
  - 例：`unset name`
- 变量被删除后不能再次使用，unset不能删除只读变量

#### （5）变量类型

- **局部变量**：局部比那里在脚本或命令中定义，仅当前shell实例中有效
- **环境变量**：所有程序，包括shell启动的程序，都能访问环境变量
- **shell变量**：由shell程序设置的特殊变量。shell变量中一部分是环境变量，一部分是局部变量

#### （6）Shell字符串

字符串可用单引号`''`、双引号`""`，也可不用引号

- **单引号`''`**

  - 限制：
    - 单引号中任何字符均会原样输出
    - 单引号字符串中==不能出现单独的一个单引号==（转义后也不行），但可成对出现，作为字符串拼接使用

- **双引号`""`**

  - 双引号中可以有变量
  - 双引号中可以出现转义字符

- **拼接字符串**

  ```
  name="type"
  greet="hi,"${name}"!"
  greet="hi,${name}!"
  ```

- **获取字符串长度**

  ```
  string="abcd"
  echo ${#string}  # 输出4
  ```

- **提取子字符串**

  ```
  string="hello, i am a boy"
  echo ${string:1:4}  # 输出ello
  ```

  - 第一个字符的索引值为0

- **查找子字符串**

  - 查找字符i或o的位置

    ```
    string="hello,i am a boy"
    echo `expr index "${string}" io` # 输出5
    ```

  - 上面是**`**，而不是**'**

#### （7）Shell数组

bash支持以为数组，不支持多维数组，且未限定数组的大小

- **定义数组**

  - shell中，用括号`()`表示数组，数据元素用空格分隔开

    `数组名=(值1 值2 值3... 值n)`

  - 定义数组还可以单独定义数组的各分量

    `array_name[0]='p'`

- **读取数组**

  - `${数组名[下标]}`

  - 使用`@`或`*`符号可以获取数组中的所有元素

    `echo ${array_name[@]}`

- **获取数组的长度**

  - 与获取字符串长度的方法相同

    ```
    # 取得数组元素的个数
    length=${#array_name[@]}
    length=${#array_name[*]}
    
    # 取得数组单个元素的长度
    lengthn=${#array_name[n]}	// n表示第几个元素
    ```

#### （8）Shell注释

以`#`开头即代表注释，会被解释器忽略

- **多行注释**

  ```
  :<<EOF
  echo "100"
  echo "101"
  echo "102"
  EOF
  ```

  `EOF`也可以使用其它符号代替

### 三、传递参数

可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：**$n**。**n** 代表一个数字，1 为执行脚本的第一个参数

特殊字符处理参数：

| 参数处理   | 说明                                        |
| ---- | ------------------------------------------------------------ |
| $#   | 传递到脚本的参数个数                                         |
| $*   | 以一个单字符串显示所有向脚本传递的参数。 如`$*`用`"`括起来的情况、以`"$1 $2 … $n"`的形式输出所有参数 |
| $$   | 脚本运行的当前进程ID号                                       |
| $!   | 后台运行的最后一个进程的ID号                                 |
| $@   | 与`$*`相同，但是使用时加引号，并在引号中返回每个参数。 如`$@`用`"`括起来的情况、以`"$1" "$2" … "$n" `的形式输出所有参数。 |
| $-   | 显示Shell使用的当前选项，与[set命令](https://www.runoob.com/linux/linux-comm-set.html)功能相同 |
| $?   | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误 |

`$*` 与` $@` 区别：

- 相同点：都是引用所有参数。
- 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则`$* ` 等价于 `"1 2 3"`（传递了一个参数），而 `$@` 等价于 `"1" "2" "3"`（传递了三个参数）

### 四、运算符

使用`expr`能完成表达式的求值操作

- **算术运算符**

  | 运算符 |  举例                          |
  | ----- | ---------------------------- |
  | +    | `$(expr $a + $b)` |
  | -    | `$(expr $a - $b)` |
  | *    | `$(expr $a \* $b)` |
  | /     | `$(expr $b / $a)`  |
  | %    | `$expr $b % $a)`   |
  | =     | `a=$b ` |
  | ==   | `[ $a == $b ] `   |
  | !=     | `[ $a != $b ] `    |
  
  - `*`前边必须加`\`才能实现乘法运算
  
  - 表达式和运算符之间要有空格
  
  - 完整的表达式要被**``**包含
  
  - **$()** 等价于 **``**
  
  - 条件表达式要放在方括号之间，并且要有空格
  
    - **[] 表达式**
  
      **注意**：在 [] 表达式中，常见的 >, < 需要加转义字符，表示字符串大小比较，以 `ascill` 码位置作为比较。不直接支持 >, < 运算符，还有逻辑运算符 || 、&& ，它需要用 -a[and] –o[or] 表示。
  
      **[[ ]] 表达式**
  
      **注意**：[[]] 运算符只是 [] 运算符的扩充。能够支持 >, < 符号运算不需要转义符，它还是以字符串比较大小。里面支持逻辑运算符：**|| &&** ，不再使用 **-a -o**。

- **关系运算符**

  | 运算符 | 说明                      |  | 举例            |
  | ----- |-------------------- | ------ | -------------- |
  | `-eq`  | 是否相等，相等返回 true | equal | `[ $a -eq $b ]` |
  | `-ne`  | 是否不相等，不相等返回 true | not equal | `[ $a -ne $b ]` |
  | `-gt`  | 是否大于，是则返回 true  | greater than | `[ $a -gt $b ]` |
  | `-lt`  | 是否小于，是则返回 true   | less than | `[ $a -lt $b ]` |
  | `-ge`  | 是否大于等于，是则返回 true | greater than or equal | `[ $a -ge $b ]` |
  | `-le`  | 是否小于等于，是则返回 true | less than or equal | `[ $a -le $b ]` |

  关系运算符只支持数字，不支持字符串

- **布尔运算符**

  | 运算符 | 说明 | 举例                |
  | :----- | :--- | :------------------ |
  | !      | 非   | `[ ! false ]`       |
  | -o     | 或   | `[ true -o false ]` |
  | -a     | 与   | `[ true -a true ]`  |

- **逻辑运算符**

  | 运算符 | 说明     | 举例                   |
  | :----- | -------- | :--------------------- |
  | &&     | 逻辑AND  | `[[ true && true ]] `  |
  | \|\|   | 逻辑的OR | `[[ true || false ]] ` |

- **字符串运算符**

  | 运算符 | 说明                 | 举例           |
  | :----- | :------------------- | :------------- |
  | =      | 字符串是否相等       | `[ $a = $b ] ` |
  | !=     | 字符串是否不相等     | `[ $a != $b ]` |
  | -z     | 字符串长度是否为0    | `[ -z $a ] `   |
  | -n     | 字符串长度是否不为 0 | `[ -n "$a" ]`  |
  | $      | 字符串是否为空       | `[ $a ]`       |

- **文件测试运算符**

  | 操作符  | 说明                                             | 举例                      |
  | :------ | :----------------------------------------------- | :------------------------ |
  | -b file | 判断是否为块设备文件                             | `[ -b $file ] `           |
  | -c file | 判断是否为字符设备文件                           | `[ -c $file ]`            |
  | -d file | 判断是否为目录                                   | `[ -d $file ]`            |
  | -f file | 判断是否为普通文件（不是目录、设备文件） | `[ -f $file ]`            |
  | -g file | 判断是否设置了` SGID` 位                         | `[ -g $file ]` |
  | -k file | 判断是否设置了粘着位(Sticky Bit)                 | `[ -k $file ]` |
  | -p file | 判断是否有名管道                                 | `[ -p $file ]` |
  | -u file | 判断是否设置了 `SUID` 位                         | `[ -u $file ]` |
  | -r file | 判断是否可读                                     | `[ -r $file ]` |
  | -w file | 判断是否可写                                     | `[ -w $file ]` |
  | -x file | 判断是否可执行                                   | `[ -x $file ]` |
  | -s file | 判断是否为空（文件大小是否大于0）                | `[ -s $file ]` |
  | -e file | 检测文件是否存在                    | `[ -e $file ]` |

### 五、echo

- **显示变量**

  read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量

  ```
  read name
  echo "$name is a boy"
  ```

- **显示换行与不换行**

  ```
  echo -e "OK!\n"  # -e开启转义
  echo "It is a test"
  ```

  ```
  echo -e "OK!\c"   # \c不换行
  echo "It is a test"
  ```

- **输出原样字符串**

  使用单引号`'`

- **显示命令执行结果**

  ```
  echo `date`
  ```

  使用的是反引号 **`**, 而不是单引号 **'**

### 六、流程控制

- **if else**

  ```
  if condition
  then
  	command1
  else
  	command2
  fi
  
  
  ```

-  **if else-if else**
  
  ```
  if condition1
  then
      command1
  elif condition2 
  then 
      command2
  else
      commandN
  fi
  ```
  
- **for循环**

  ```
  for var in item1 item2 ... itemN
  do
      command1
      command2
      ...
      commandN
  done
  ```

- **while循环**

  ```
  while condition
  do
      command
  done
  ```

- **until循环**

  一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用

  ```
  until condition
  do
      command
  done
  ```

- **`case...esac`**

  每个 case 分支用右圆括号`)`开始，用两个分号 **;;** 表示 break

  ```
  case 值 in
  模式1)
      command
      ;;
  模式2）
      command2
      ;;
  esac
  ```

  取值后面必须为单词 **in**，每一模式必须以右括号结束

  一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式

  若==无一匹配模式==，使用星号 * 捕获该值，再执行后面的命令。

### 七、Shell函数

```
[ function ] name ()
{
    action;
    [return int;]
}
```

说明：

- 可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。
- 参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255

==函数返回值在调用该函数后通过 `$? `来获得==

注意：**所有函数在使用前必须定义**。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。

### 八、Shell输入/输出重定向

| 命令            | 说明                                             |
| :-------------- | :----------------------------------------------- |
| command > file  | 将输出重定向到 file                              |
| command < file  | 将输入重定向到 file                              |
| command >> file | 将输出以追加的方式重定向到 file                  |
| n > file        | 将文件描述符为 n 的文件重定向到 file             |
| n >> file       | 将文件描述符为 n 的文件以追加的方式重定向到 file |
| n >& m          | 将输出文件 m 和 n 合并                           |
| n <& m          | 将输入文件 m 和 n 合并                           |
| << tag          | 将开始标记 tag 和结束标记 tag 之间的内容作为输入 |

- 需要注意的是文件描述符 `0 `通常是标准输入（`STDIN`）

  `1 `是标准输出（`STDOUT`）

  `2 `是标准错误输出（`STDERR`）`2>`是一体的时候才表示错误输出

- **Here Document**

  ```
  command << delimiter
      document
  delimiter
  ```

  它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command

  - 结尾的delimiter顶格写，前面不能有任何字符，后面也不能有任何字符
  - 开始的delimiter前后的空格会被忽略掉

  ```
  cat <<EOF
      123
  EOF
  ```

- **`/dev/null`文件**

  `/dev/null`是一个特殊的文件，写入到它的内容都会被丢弃；从该文件读取内容，什么也读不到

  将命令的输出重定向到它，会起到"禁止输出"的效果

### 九、Shell文件包含

```
. filename   # 注意点号(.)和文件名中间有一空格

或

source filename
```

### 十、read命令

`read [-options] [variables]`

- `options`表示选项，如下表所示；`variables`表示用来存储数据的变量，可以有一个，也可以有多个。

- `options`和`variables`都是可选的，如果没有提供变量名，那么读取的数据将存放到环境变量 REPLY 中。

  | 选项           | 说明                                                         |
  | -------------- | ------------------------------------------------------------ |
  | `-a array`     | 把读取的数据赋值给数组 array，从下标 0 开始。                |
  | `-d delimiter` | 用字符串 delimiter 指定读取结束的位置，而不是一个换行符（读取到的数据不包括 delimiter）。 |
  | `-e`           | 在获取用户输入的时候，对功能键进行编码转换，不会直接显式功能键对应的字符。 |
  | `-n num`       | 读取 `num` 个字符，而不是整行字符。                          |
  | `-p prompt`    | 显示提示信息，提示内容为 prompt。                            |
  | `-r`           | 原样读取（Raw mode），不把反斜杠字符解释为转义字符。         |
  | `-s`           | 静默模式（Silent mode），不会在屏幕上显示输入的字符。当输入密码和其它确认信息的时候，这是很有必要的。 |
  | `-t seconds`   | 设置超时时间，单位为秒。如果用户没有在指定时间内输入完成，那么 read 将会返回一个非 0 的退出状态，表示读取失败。 |
  | `-u fd`        | 使用文件描述符 `fd` 作为输入源，而不是标准输入，类似于重定向。 |

### 十一 返回值

`$?`

- `$?`的范围在0~255之间

- `$?`是接收上一条函数的执行结果



严格来说，Shell 函数中的 return 关键字用来表示函数的退出状态，而不是函数的返回值；Shell 不像其它编程语言，没有专门处理返回值的关键字

- Shell 函数返回值只能是整形数值
- 一般是用来表示函数执行成功与否的，0表示成功，其他值表示失败
