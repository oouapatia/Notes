[toc]

- 通过系统调用来访问文件是最直接的方式。系统调用函数直接作用于操作系统内核的设备驱动程序从而实现文件访问

#### 1、文件描述符

程序开始运行时，文件一般会有三个已经打开的文件描述符：

- `0`：标准输入
- `1`：标准输出
- `2`：标准错误

其它文件的文件描述符，在调用文件打开函数（`open()`）时返回

#### 2、write()

将缓冲区的数据写入文件中

**（1）原型**

`Linux`中`write()`的函数原型

- `size_t write(int fildes, const void *buf, size_t nbytes);`

  **参数**

  - `fildes`：文件描述符，标识了要写入的目标文件
  - `*buf`：待写入的文件，是一个字符串指针
  - `nbytes`：要写入的字符数

**（2）返回值**

size_t  返回成功写入文件的字符数

**（3）例**

```
int a = open("1.txt", O_WRONLY);
write(a, "here is some data\n", 18);
```

#### 3、open()

需要添加头文件`<fcntl.h>`

**（1）原型**

`Linux`中`open()`的函数原型

- ```
  int open(const char *path, int oflags);
  int open(const char *path, int oflags, mode_t mode );
  ```

  **参数**

  - `path`：需要打开的文件路径

  - `oflags`：文件的访问模式

    | 模式       | 说明             |
    | ---------- | ---------------- |
    | `O_RDONLY` | 以只读方式打开   |
    | `O_WRONLY` | 以只写的方式打开 |
    | `O_RDWR`   | 以读写的方式打开 |

    `oflags`读写模式可与下面组合作为参数（按位或（`|`）后得到）

    | 模式       | 说明                                           |
    | ---------- | ---------------------------------------------- |
    | `O_APPEND` | 把写入数据追加在文件的末尾                     |
    | `O_TRUNC`  | 把文件长度设为0，丢弃以后的内容                |
    | `O_CREAT`  | 如果需要，就按参数mode中给出的访问模式创建文件 |
    | `O_EXCL`   | 与`O_CREAT`一起调用，确保调用者创建出文件      |

  - `mode`：`O_CREAT`标志的open来创建文件时，我们必须使用三个参数格式的open调用。第三个参数mode 是几个标志按位或后得到的

    | mode      | 说明 |
    | --------- | ---- |
    | `S_IRUSR` |   读权限，文件属主   |
    | `S_IWUSR` |   写权限，文件属主   |
    | `S_IXUSR` |   执行权限，文件属主   |
    | `S_IRGRP` |  读权限，文件所属组    |
    | `S_IWGRP` |   写权限，文件所属组   |

    

