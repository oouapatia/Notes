[toc]

### 1、引入`inline`关键字

c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，引入`inline`修饰符表示为内联函数

在系统下，栈空间是有限的，若频繁大量的使用就会造成因栈空间不足而导致程序出错的问题。如函数的死循环递归调用的最终结果就是导致栈内存空间枯竭

在任何调用内联函数的地方都换成内联函数的函数体，避免了频繁调用函数对栈内存重复开辟所带来的消耗

### 2、`inline`的使用限制

`inline`只适合函数体内代码简单的函数使用，不能包含复杂的结构控制语句，如while、switch，并且内联函数本身不能是直接递归函数（自己内部调用自己）

### 3、`inline`只是一个对编译器的建议

`inline`函数仅仅是一个对编译器的建议，所以最后是否能真正内联，需要看编译器，若它认为函数不复杂，能在调用点展开，则会真正内联

### 4、`inline`函数定义建议放在头文件中

内联函数要在调用点展开，要求每个调用了内联函数的文件都要有该内联函数的定义

声明要与定义一致

### 5、类中的成员函数与`inline`

==**定义**==在类中的**==成员函数==**默认都是内联的；若未在类中给出成员函数定义，同时想内联该函数时，需要在类外加上`inline`，否则就认为不是内联的

定义：`void Foo(int x){}`

### 6、`inline`是一种用于实现的关键字

关键字`inline`必须与函数定义体放在一起才能使函数成为内联，仅仅将`inline`放在函数声明前不起任何作用

- **例：**

  ```
  void Foo(int x);
  inline void Foo(int x){return x;}
  ```

### 7、注意

内联是以**代码膨胀（复制）**为代价的，仅仅省去了函数调用的开销，从而提高函数的执行效率

若执行函数体代码的开销要大于函数调用，收获的效率会很少；每一处内联函数的调用都要复制代码，使程序的总代码量增大，消耗更多的内存空间。

**以下情况不宜使用内联：**

- 函数体内的**代码较长**，使用内联将导致**内存消耗代价较高**
- 函数体内出现**循环**，那么执行函数体内代码的时间要比函数调用的开销大
- 类的构造函数和析构函数容易使人误解成使用内联函数更有效，要当心**构造函数与析构函数可能会隐藏一些行为**，如“偷偷”执行了**基类或成员对象**的构造或析构函数。故**不要随便地将构造函数与析构函数的定义体放在类声明中**。

> 如果函数并不是很短而且在很多地方被调用，使用内联函数将会使得可执行体的体积增大