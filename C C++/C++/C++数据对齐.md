[toc]

[C++ 数据对齐 问题](http://www.vvbin.com/?p=553)

> 64位计算机，总线位宽为64个比特（bit），即8个字节（byte），CPU的寄存器也是8个字节大小，所以访问内存也总是以8个字节为单位；
>
> 若一份不足8字节大小数据因为布局问题跨越了两个8字节单位，在读这份数据时，就需要通过两次总线传输，传递16字节的数据，CPU也要分配缓存这16字节的数据，属实离谱；
>
> 数据对齐就是要求数据应该排放在其大小的自然边界上，简单说就是大小为N(1,2,4,8,16,32)的数据不应该放在两个N格子之间，而应该放在一个单独的格子内

### 编译器关于数据对齐的策略

#### 1、规则一：成员变量根据自己的大小来对齐

> 关于结构体内该成员是否要对齐，对齐到什么位置，是看自己；

定义一个`int`，就要对齐到`sizeof(int)`整数倍的位置；定义一个`double`，就要对齐到`sizeof(double)`整数倍的位置

#### 2、规则二：结构体大小必须是最大成员变量大小的整数倍

> 规则二定义的是结构体最后补齐的情况

- 如果一个结构体中定义了一个`double`与`int`，则最大成员变量是`double`，大小为8

  结构体大小虽然为4（`int`）+8（`double`）=12字节，但会**补齐为8的整数倍16**；这样做是为了处理结构体数组时，每一个结构体内的每一个成员变量都处于边界上

**例：**

```
typedef struct {
	char c;
	int n;
	short s;
}s0;
```

结构体`s0`对齐后的布局：每个格子代表一个字节，`*`代表用于内存对齐的无效数据

> |c|`*`|`*`|`*`|n|n|n|n|s|s|`*`|`*`| 

- 第一个为`char`，1字节；

- 第二个为`int`，4字节，**根据规则一**，int的布局要对齐到4的整数倍上，所以会从第五个格子开始；故`int`前会有3个字节的空位，是用于内存对齐的无效数据；

- 第三个为`short`，2字节；
- **根据规则二**，整个`s0`的大小需要是最大成员`int`（4）的整数倍（12），所以还会在`short`后填充2个字节的无效数据用作数据对齐；

#### 3、规则三：对于结构体内的子结构体，子结构体以其最大成员大小为边界进行对齐

> 规则三是规则一的补充，即当成员是一个结构体时，这时候成员对齐的边界不是整个子结构体的大小，而是子结构体内最大成员的大小

**例：**

```
typedef struct {
	short a;
	long b;
}s1;
typedef struct {
	char c;
	s1 d;
	long long e;
}s2;
```

> `s2`的第二个成员是结构体`s1`，在处理`s1`的对齐时，应该按照`s1`的最大成员`long`的大小（8）来对齐，而不是整个`s1`的大小对齐

结构体`s2`对齐后的内存布局：

> |c|`*`|`*`|`*`|`*`|`*`|`*`|`*`|a|a|`*`|`*`|`*`|`*`|`*`|`*`|b|b|b|b|b|b|b|b|e|e|e|e|e|e|e|e|

-  第一个为`char`，放在第一个位置；
- 第二个`s1`，是结构体，**按照规则三**应该按`s1`中最大的成员`long`来对齐，放在8的整数倍上（8），即从第9位开始放，所以在`s1`前会有7个字节的无效数据；
  - `s1`中第一个为`short`，放在第9、10位；
  - `s1`中第二个为`long`，放在8的整数倍上（16）即从第17位开始放，故在`long`前会有6个字节的无效数据；
- 第三个`long long`，**按规则一**应该按自己的大小（8）来对齐，放在8的整数倍上（24），即从第25位开始放；
- **根据规则二**，`s2`应该是最大成员`long long`的整数倍（24），放完`long long`刚好24，不需填充无效字节；

#### 3、通过编译指令指定对齐

- `#pragram pack(n)`：告诉编译器按照`n`大小进行对齐

  `n`值可取：1，2，4，6，16，32

- 指定大小`n`后，编译器就会按照`min(n, sizeof(data))`对齐，无论成员数据多大，都会按照`n`字节对齐

#### 4、注意

1. **更合理的组织结构**

   > 将数据类型按一定的大小顺序进行定义，由小到大或由大到小

   **例：**一个结构体包含2个`char`，1个`int`；

   - 若按`char` `char` `int`的布局，这个结构体需要8个字节，布局：

     > |c|c|`*`|`*`|i|i|i|i|

   - 若按`char` `int` `char`的布局，这个结构体则需要12个字节，布局：

     > |c|`*`|`*`|`*`|i|i|i|i|c|`*`|`*`|`*`|

2. **回避依赖内存布局的算法**

#### 5、代码验证

使用`sizeof`函数验证结构体大小

```
#include <iostream>
using namespace std;

typedef struct {
    char c;
	int n;
	short s;
}s0;

typedef struct {
	short a;
	long b;
}s1;

typedef struct{
	char c;
	s1 d;
	long long e;
}s2;

typedef struct {
	char a;
	char b;
	int c;
}s3;

typedef struct {
	char a;
	int b;
	char c;
}s4;

int main(){
	cout << "char:" << sizeof(char) << endl;
	cout << "int:" << sizeof(int) << endl;
	cout << "short:" << sizeof(short) << endl;
	cout << "long:" << sizeof(long) << endl;
	cout << "long long:" << sizeof(long long) << endl << endl;

    cout << "s0:" << sizeof(s0) << endl;
    cout << "s1:" << sizeof(s1) << endl;
    cout << "s2:" << sizeof(s2) << endl << endl;

	cout << "s3:" << sizeof(s3) << endl;
	cout << "s4:" << sizeof(s4) << endl;
    return 0;
}
```



