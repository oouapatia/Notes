[toc]

[C语言中的二等公民在C++是如何翻身的](https://blog.csdn.net/vincent040/article/details/119717173)

### 1、`enum`

> 定义枚举类型，枚举的本子含义是一种取值范围受限的整数；

```
typedef enum
{
    red,
    blue,
}color;
```

- red默认为0，后面的值依次递增

- ```
  color c;
  c = blue;	// 正确
  c = 1;			// 错误
  ```

  在给`c`赋值时，只能用color中的值，不能直接用整数进行赋值，会破坏枚举的可读性

### 2、`const`

1. `const`定义具有类型的常量，用来代替宏定义

   - `const float PI = 3.1415;`
   - 上述定义语句比宏定义要好，因为**`const`具有类型检测**，但是宏定义没有类型检测；

2. 用以区分函数特征标

   函数本身使用`const`来修饰，或者某个参数使用`const`来修饰，都能使得函数的特征标发生改变，从而可以被重载；`const`版本的函数只能用`const`常对象来调用

3. 用来提高程序的健壮性和执行效率。将不需要修改其值的变量都用`const`来修饰，即能用`const`的地方就用`const`；

### 3、`auto`

> C++中auto意味着“自动类型推导”

在定义一个变量时，若无法确定其类型，但可以由赋值的数据的类型来自动匹配

```
for (auto iter = infoVec.begin(); iter != infoVec.end(); ++iter) {

}
```

### 4、`define`

> 在C++中被`cosnt`常量，`inline`函数替代

**宏定义的缺点：**

- 无法确定类型；
- 复杂带参宏的逻辑难以理解

> C++为了保留宏的优点（直接在代码调用处展开，无需跳转），发明了内联函数；
>
> 内联函数本身是函数，因此不存在宏定义宏参数无类型、无语法检查等缺点；同时内联函数**编译阶段**（而不是预处理阶段）将代码直接插入调用的地方，无需跳转，具有宏执行快速的优点





