#### 1、智能指针

> 智能指针是一个`RAII`（`Resource acquire is initialization`资源获取就是初始化）类模型，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使delete删除指针锁指向的内存空间

#### 2、智能指针作用

> 处理内存泄露问题和空悬指针问题

#### 3、智能指针的分类

分为`auto_ptr`、`unique_ptr`、`shared_ptr`、`weak_ptr`四种

##### 1、`auto_ptr`

对于`auto_ptr`实现**独占式拥有**的概念，同一时间只能有一个智能指针可以指向该对象；

但在C++11中被摒弃，其主要问题在于：

- 对象所有权的转移，比如在函数传参过程中，对象所有权不会返还，从而存在潜在的内存崩溃问题；
- 不能指向数组，也不能作为`STL`容器的成员

##### 2、`unique_ptr`

对于`unique_ptr`，实现**独占式拥有**的概念，同一时间只能有一个智能指针可以指向该对象，因为无法进行拷贝构造和拷贝赋值，但是**可以进行移动构造和移动赋值**；

##### 3、`shared_ptr`

对于`shared_ptr`，实现**共享式拥有**的概念，即多个智能指针可以指向相同的对象，该对象及相关资源会在其所指对象不再使用之后，**自动释放与对象相关的资源**；

**实现：**

1. 构造函数中计数初始化为1；
2. 拷贝构造函数中计数值加1；
3. 赋值运算符中，左边的对象引用计数减1，右边的对象引用计数加1；
4. 析构函数中引用计数减1；
5. 在赋值运算符和析构函数中，如果减1后为0，则调用delete释放对象

##### 4、`weak_ptr`

对于`weak_ptr`，**解决`shared_ptr`相互引用**时，两个指针的引用计数永远不会下降为0，从而导致死锁问题。而`weak_ptr`是对对象的一种弱引用，可以绑定到`shared_ptr`，但不会增加对象的引用计数

#### 5、使用

````c++
shared_ptr<int> ptra = make_shared<int>(a);	 // 定义
shared_ptr<int> = ptra2(ptra);									// copy
int *pa = ptra.get();														  // 获取原始指针
int count = ptra.use_count();									  // 获取资源的引用计数

weak_ptr<int> wp(ptra);
if (!wp.expired()) {}														  // expired函数：等价于0 == user_count()
````





