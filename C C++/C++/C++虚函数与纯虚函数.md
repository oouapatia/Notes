[toc]

> 一个类函数的调用并不是在编译时被确定的，而是在运行时被确定的

### 1、虚函数

> 派生类中若使用同名函数“实装”基类的虚函数，则在使用时调用派生类的；若派生类没有同名函数，则仍用基类的虚函数实装
>
> 定义虚函数是为了允许用基类的指针来调用派生类的这个函数

#### （1）格式

- `virtual void functionName(){}`

#### （2）虚函数与虚继承的区别

> “虚函数”与“虚继承”是两个不同的概念，“虚继承”针对基类的成员变量的二义性，而“虚函数”是针对成员函数的二义性。
>
> “虚继承”是将“virtual”加在派生类的定义处，“虚函数”是将“virtual”加在基类的成员函数的定义处

**虚函数只能借助于指针或者引用来达到多态的效果**

### 2、纯虚函数

> 包含“纯虚函数”的类，不能产生实例，被称之为抽象类，不能创建抽象类的实例
>
> 定义纯虚函数是为了实现一个接口，使派生类仅仅只是继承函数的接口，起到一个规范作用

#### （1）格式

- `virtual void functionName() = 0;`

#### （2）注意

> 若抽象类的派生类未实现其纯虚函数，则抽象类的派生类仍是一个抽象类
>
> 实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数，派生类的派生类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定
>
> C++仍然保留了基类提供该纯虚函数代码实现的权利，并非为了多态，因为指向子类对象的基类指针和引用无法调用该版本。纯虚函数在基类中的实现与多态性无关，只是提供一种语法上的便利，在变化多端的应用场景中留有后路

### 3、总结

> - 对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定
> - 虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数
> - 有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的
> - 友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题
> - 析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数

